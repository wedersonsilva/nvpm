*nvpm.txt*               Project Manager for Neovim

╭────────────────────────────────────────────────╮
│                                           ╭───╮│
│                                           │   ││
│                                 ╭─────────┤   ││
│                               ╭─┴─╮       │   ││
│                               │   │       ╰───╯│
│                    ╭──────────┤   │            │
│                    │          │   │       ╭───╮│
│                  ╭─┴─╮        ╰─┬─╯       │   ││
│                  │   │          ╰─────────┤   ││
│                  │   │                    │   ││
│                  │   │                    ╰───╯│
│                  ╰─┬─╯                         │
│                    │          ╭───╮       ╭───╮│
│                    ╰──────────┤   │       │   ││
│                               │   ├───────┤   ││
│                               │   │       │   ││
│                               ╰───╯       ╰───╯│
│                                                │
│     ███╗   ██╗██╗   ██╗██████╗ ███╗   ███╗     │
│     ████╗  ██║██║   ██║██╔══██╗████╗ ████║     │
│     ██╔██╗ ██║██║   ██║██████╔╝██╔████╔██║     │
│     ██║╚██╗██║╚██╗ ██╔╝██╔═══╝ ██║╚██╔╝██║     │
│     ██║ ╚████║ ╚████╔╝ ██║     ██║ ╚═╝ ██║     │
│     ╚═╝  ╚═══╝  ╚═══╝  ╚═╝     ╚═╝     ╚═╝     │
│                                                │
╰────────────────────────────────────────────────╯
==================================================
|Creator|                             Itamar Soares

                           iasoresjr@gmail.com
                           https://github.com/iasj
==================================================
|NVPM-Organization|
   
-> https://github.com/nvpm/nvpm
   https://github.com/nvpm/line
   https://github.com/nvpm/zoom
   https://github.com/nvpm/skel
   https://github.com/nvpm/todo
==================================================
CONTENTS                                      *nvpm*

|0|  Quick Start     ...... |nvpm-for-lazy-people|
|1|  Installation    ...... |nvpm-installation|
|2|  Introduction    ...... |nvpm-intro|
|3|  Context         ...... |nvpm-context|
|4|  NVPM Lang & Use ...... |nvpm-markup-lang-use|
|5|  Commands        ...... |nvpm-commands|
|6|  Configuration   ...... |nvpm-configuration|
|7|  Functions       ...... |nvpm-functions|
|8|  Autocommands    ...... |nvpm-autocommands|
|9|  Syntax          ...... |nvpm-syntax-highlight|
|10| NVPM Workflow   ...... |nvpm-workflow|

<TODO>: fix multiple helptags problem!
==================================================

|0| Quick Start           *nvpm-for-lazy-people* {

Comming soon!

<TODO>
Build quick test engine for new users. 
Use autoload mechanism.

}
|1| Installation             *nvpm-installation* {

<TODO>

}
|2| Introduction                    *nvpm-intro* {

NVPM stands for NeoVim Project Manager. 

It's mission is to assist the user on managing 
large quantities of files in any project. 

The main goal is to create a tree-like structure
in order to overcome the linearity of Neovim's
bufferlist.

To do that, the creator was forced to totally
ignore how Neovim handles each loaded file.

The approach here is to make a plan about which
files the user wants to open and then write what
is called a project file descriptor. Those files
follow the NVPM Markup Language, which was
specificaly created for the only purpuse of
describing which files the user will open every
time nvpm is called.

}
|3| Context                       *nvpm-context* {

For small projects, Neovim's bufferlist will do
just fine. You can open all the files in different
tabs and move arround with ease. The problem only
appears when you increase the number of files and
directories in your project.

<TODO>
  put nvpm in front of libgeo tags

To exemplify this, we can create a hypothetical
project. A C Library that handles geometric 
calculations called `LibGeo`. This project may 
start small, say:
                                    *small-libgeo*
>
  $tree ~/libgeo/

  libgeo/
  ├── main.c
  └── readme.txt
  
  0 directories, 2 files
<

In such cases, the user can open each file at a
time and edit them separately. But very soon 
the situation can change into separate modules 
for the library. Say:
                                   *medium-libgeo*
>
  tree ~/libgeo/

  libgeo/
  ├── main.c
  ├── readme.txt
  └── src
      ├── line.c
      ├── line.h
      ├── plane.c
      ├── plane.h
      ├── point.c
      └── point.h

  1 directory, 8 files
<

It can always get uglier! The user might want to
make separate tests, assisted by a Makefile. Also,
as soon as the modules increase in number, more 
hierarchies might be necessary. 

And what about creating a git repository, a
documentation folder, install, uninstall and
helper scripts. Well, very quickly, the user 
might face the following structure of files:
                                    *large-libgeo*
>
  tree -a libgeo/

  libgeo/
  ├── bin
  ├── doc
  │   ├── libgeo-dev.txt
  │   └── libgeo.txt
  ├── .gitignore
  ├── lib
  ├── Makefile
  ├── readme.txt
  ├── scripts
  │   ├── helper.sh
  │   ├── install.sh
  │   └── uninstall.sh
  ├── src
  │   ├── common.h
  │   ├── data
  │   │   ├── list.c
  │   │   ├── list.h
  │   │   ├── string.c
  │   │   ├── string.h
  │   │   ├── tree.c
  │   │   └── tree.h
  │   ├── main.c
  │   ├── math
  │   │   ├── complex.c
  │   │   ├── complex.h
  │   │   ├── matrix.c
  │   │   ├── matrix.h
  │   │   ├── real.c
  │   │   ├── real.h
  │   │   ├── vector.c
  │   │   └── vector.h
  │   └── shapes
  │       ├── line.c
  │       ├── line.h
  │       ├── plane.c
  │       ├── plane.h
  │       ├── point.c
  │       └── point.h
  └── test
      ├── common.h
      ├── data
      │   ├── list.c
      │   ├── list.h
      │   ├── string.c
      │   ├── string.h
      │   ├── tree.c
      │   └── tree.h
      ├── main.c
      ├── math
      │   ├── complex.c
      │   ├── complex.h
      │   ├── matrix.c
      │   ├── matrix.h
      │   ├── real.c
      │   ├── real.h
      │   ├── vector.c
      │   └── vector.h
      └── shapes
          ├── line.c
          ├── line.h
          ├── plane.c
          ├── plane.h
          ├── point.c
          └── point.h

  12 directories, 52 files

<
Well how about that? Not only we have many more 
files and directories, divided into folders and
subfolders, but now we have different categories 
of files. If the user tries to open them all, 
only one instance of Neovim won't be enough to 
keep track of them all.

And even if the user defies logic and open all of
them, there won't be enough screen to place them
which may force the user to create splits, tabs, 
hidden buffers, etc, etc.

<TODO>:
  more info on why NVPM helps (degrees of freedom)

}
|4| NVPM Lang & Use       *nvpm-markup-lang-use* {

|4.0| Introduction                               {

The previous versions of NVPM (v1.0.0 & v2.0.0)
used two different settings files to describe the
workspaces, tabs and buffers. Besides, in the very
first version, there wasn't the consept of 
workspace, there was only the list of tabs and
buffers. Whereas the second version, the creator
used JSON files to structure the information
required to describe the projects's meta-data.

This latter approach was easier to implement when
used with Neovim's "exec" command and for the fact
the JSON and VimLang dictionaries are similar.


SEE *nvpm-history*

}
|4.1| NVPM Markup Language                       {

|4.1.0| What does it do?                         {

NVPM Markup Language was designed in such a way to
facilitate the creation of workspaces. Workspace
means a space that you can work with/on/in. 

The language is written in what is defined as
project files. Those files store a list of 
workspaces written by the user, using NVPM Markup 
Language.

The user may write as many project files as
necessary. No limits was imposed by the creator.
Normally, only one project file may be enough for
small to medium sized projects. I'll let you be 
the judge of that! So feel free to exploit all 
of NVPM's capabilities.

The project files will have information regarding
the meta-data of each project. Meta-data is all
the information that is not (may not be) stored
inside the files. As an example:

>
  name of files
  name of directories
  specific concepts about the files/software
  or basically anything the user deems necessary
<

There is no correct rule here, Keep reading! There
will be complete examples of this subject below in
this file.

What NVPM will do with this meta-information is to
read and apply actions accordingly, such as:
>
  opening files
  opening terminals
  building tab and status lines
  boring stuff the user may not wanna know
<
     but developers might!
     SEE |nvpm-development|

Note. There is no other way to use NVPM but by
creating at least one project file. If the user
wants to use it, make sure to read this document
first.

}
|4.1.1| Location of Project Files                {

By default, NVPM searches for project files inside
the folder ".nvpm/proj/". The user may change this
default location with the following variable:


`g:nvpm_local_dir`

<TODO>: link with variable description

That must be set somewhere in the user's init.vim.

This folder must be embeded with each project. So
in our LibGeo example:
                                SEE |nvpm-context|

>
  project's location: ~/libgeo/
  then the folder ~/libgeo/.nvpm/proj/ must exist!
<
<TODO>
  link with NVPMNewProject command description

Some plugins use a hidden ".vim" folder to store
sensible information. In such cases (or for no 
reason at all), the user may want to change the 
default location for the local directory, say:


`let g:nvpm_local_dir = '.vim/nvpm'`


Make no attemps to change the sub-folder "proj"
inside the local directory! This name was chosen 
by the creator, and it's hardcoded in the script.

Future designs of NVPM will allow the user to
create global project files somewhere. This feature
is under development and will be ready when it's 
ready!

}
|4.1.2| NVPM Markup Lang Reserved Keywords       {


The markup language to describe projects is having
the folowing keywords:

>
  workspace
  tab
  buff
  term
<

<TODO>: put link when it's ready!
SEE ** for new projects


workspace: receives a name                        {

  Syntax  : `workspace <workspace-name>`
  Examples:
>
  workspace Code
  workspace Docs
  workspace LibGeo Code
  workspace LibGeo Scripts
<

}
tab      : receives a name                        {

  Syntax  : `tab <tab-name>`
  Examples:
>
    tab Main
    tab Doc
<

}
buff     : receives name and a path               {

  Syntax  : `buff <buffer-name> : /path/to/file`
  Examples:                   

>
  buff main : src/main.c
  buff make : Makefile
  buff vnit : ~/.config/nvim/init.vim
<

}
term     : receives name and command              {

  Syntax  : `term <terminal-name> : <command>`
  Examples:                   

>
  term home :         <-- $SHELL by default
  term home : bash    <-- calling bash
  term tree : ranger
<

}

}
|4.1.3| NVPM Markup Lang Complete Examples       {

SEE |nvpm-context| first!

                                    
<1st-example> Small LibGeo          |small-libgeo|

>
  // Location: ~/libgeo/.nvpm/proj/libgeo.nvpm

  workspace LibGeo
    tab Main
      buff Code : main.c
      buff read : readme.txt
<

                                   
<2nd-example> Medium LibGeo        |medium-libgeo|

>
  // Location: ~/libgeo/.nvpm/proj/libgeo.nvpm
  
  workspace LibGeo

    tab Main
      buff Main : main.c
      term Term : bash

    tab Point
      buff source:src/point.c
      buff header:src/point.h

    tab Line
      buff source:src/line.c
      buff header:src/line.h

    tab Plane
      buff source:src/plane.c
      buff header:src/plane.h
<
                                    
<3rd-example> Large LibGeo          |large-libgeo|

>
  // Location: ~/libgeo/.nvpm/proj/libgeo.nvpm
  
  workspace LibGeo

    tab Main
      buff Main    : src/main.c
      buff Common  : src/common.h
      buff Makfile : Makefile
      term Term    : bash

    tab Math Pack
      buff comp C : src/math/complex.c
      buff comp H : src/math/complex.h
      buff real C : src/math/real.c
      buff real H : src/math/real.h
      buff vect C : src/math/vector.c
      buff vect H : src/math/vector.h
      buff matx C : src/math/matrix.c
      buff matx H : src/math/matrix.h

    tab Data Pack
      buff list C : src/data/list.c
      buff list H : src/data/list.h
      buff strg C : src/data/string.c
      buff strg H : src/data/string.h
      buff tree C : src/data/tree.c
      buff tree H : src/data/tree.h


}

}
|4.2| NVPM Usage                                 {

SEE *nvpm-context* first!



}

}

==================================================














vim: ft=help tw=50 isk+=<,>,\:,-,'
